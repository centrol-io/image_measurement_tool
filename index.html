<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Layer Area & Wall Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; }
        canvas { background-color: transparent; cursor: crosshair; display: block; border-radius: 0.5rem; touch-action: none; }
        .distance-label { position: absolute; background-color: rgba(0, 0, 0, 0.75); color: white; padding: 3px 6px; font-size: 0.8rem; border-radius: 0.25rem; pointer-events: none; white-space: nowrap; z-index: 10; transform: translate(-50%, -50%); box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        html, body { height: 100%; margin: 0; }
        .main-container { display: flex; flex-direction: column; min-height: 100vh; }
        .canvas-container { position: relative; flex-grow: 1; width: 100%; height: 55vh; background-size: contain; background-position: center; background-repeat: no-repeat; border-radius: 0.5rem; background-color: #f0f9ff; overflow: hidden; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); margin-bottom: 1rem; border: 2px dashed transparent; transition: border-color 0.2s ease-in-out; }
        .canvas-container.drag-over { border-color: #3b82f6; }
        #drawingCanvas { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        label, select, input, button { margin-top: 0.5rem; margin-bottom: 0.5rem; }
        select, input[type="number"] { border: 1px solid #ccc; padding: 0.5rem; border-radius: 0.375rem; }
        input[readonly] { background-color: #e5e7eb; cursor: not-allowed; }
        button { transition: background-color 0.2s ease-in-out; }
        input[type="file"] { display: none; }
        .custom-file-upload { border: 1px solid #ccc; display: inline-block; padding: 8px 12px; cursor: pointer; background-color: #e5e7eb; color: #374151; border-radius: 0.375rem; font-weight: 500; text-align: center; }
        .custom-file-upload:hover { background-color: #d1d5db; }
        #messageBox { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 12px 25px; border-radius: 8px; z-index: 1000; display: none; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.2); text-align: center; }
        #scaleDefinition { background-color: #fffbeb; border: 1px solid #facc15; border-radius: 0.375rem; padding: 0.75rem; margin-top: 0.5rem; }
        /* Layer Tabs Styles */
        .layer-tabs { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #e5e7eb; }
        .layer-tab { padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 0.375rem; cursor: pointer; background-color: #f9fafb; color: #374151; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease-in-out; position: relative; }
        .layer-tab:hover { background-color: #f3f4f6; border-color: #9ca3af; }
        .layer-tab.active { background-color: #3b82f6; color: white; border-color: #3b82f6; }
         .layer-tab .rename-input { width: 80px; font-size: 0.875rem; padding: 2px 4px; border: 1px solid #9ca3af; border-radius: 0.25rem; margin-right: 5px; color: #374151; }
        .layer-tab .close-btn { position: absolute; top: -5px; right: -5px; background-color: #ef4444; color: white; border-radius: 50%; width: 18px; height: 18px; font-size: 12px; line-height: 16px; text-align: center; cursor: pointer; border: 1px solid white; opacity: 0.7; transition: opacity 0.2s; }
         .layer-tab:hover .close-btn { opacity: 1; } .layer-tab.active .close-btn { opacity: 1; }
        #addLayerButton { padding: 0.5rem 1rem; border: 1px dashed #9ca3af; background-color: #f9fafb; color: #6b7280; }
        #addLayerButton:hover { background-color: #f3f4f6; border-color: #6b7280; color: #374151; }
        /* Summary Table Styles */
        .summary-table { width: 100%; margin-top: 1rem; border-collapse: collapse; background-color: white; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1); border-radius: 0.5rem; overflow: hidden; }
        .summary-table th, .summary-table td { border: 1px solid #e5e7eb; padding: 0.75rem 1rem; text-align: left; font-size: 0.875rem; }
        .summary-table th { background-color: #f9fafb; font-weight: 600; color: #374151; }
        .summary-table td { color: #4b5563; } .summary-table tr:nth-child(even) td { background-color: #f9fafb; }
        .summary-table tfoot td { font-weight: 600; background-color: #f3f4f6; } .summary-table .area-col { text-align: right; }
        /* Drawing Mode Radio Buttons */
        .mode-selector input[type="radio"] { display: none; /* Hide actual radio */ }
        .mode-selector label { padding: 0.5rem 1rem; border: 1px solid #d1d5db; border-radius: 0.375rem; cursor: pointer; background-color: #f9fafb; color: #374151; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease-in-out; }
        .mode-selector input[type="radio"]:checked + label { background-color: #60a5fa; /* Lighter blue */ color: white; border-color: #3b82f6; }
        .mode-selector label:hover { background-color: #f3f4f6; }
        .mode-selector input[type="radio"]:checked + label:hover { background-color: #3b82f6; /* Darker blue on hover when checked */ }

    </style>
</head>
<body class="bg-gray-100">

    <div id="messageBox"></div>

    <div class="main-container p-4 md:p-6 lg:p-8 max-w-7xl mx-auto">

        <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800 mb-4">Multi-Layer Area & Wall Calculator</h1>
        <p id="instructionText" class="text-center text-gray-600 mb-2">Add or select a layer to begin.</p>

        <div id="layerTabsContainer" class="layer-tabs">
            <button id="addLayerButton" class="layer-tab">+</button>
        </div>

         <div class="layer-controls bg-gray-50 p-3 rounded-lg shadow-sm mb-4 flex flex-wrap items-center justify-center gap-x-4 gap-y-2">
             <span class="text-sm font-medium text-gray-700">Active Layer Controls:</span>
             <div class="flex items-center gap-2">
                 <label for="ceilingHeightInput" class="text-sm font-medium text-gray-700 whitespace-nowrap">Ceiling Height:</label>
                 <input type="number" id="ceilingHeightInput" value="8" min="0" step="0.1" class="w-20 border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                 <span id="ceilingHeightUnit" class="text-sm text-gray-600">ft</span> </div>
             <div class="flex items-center gap-2 mode-selector">
                 <span class="text-sm font-medium text-gray-700">Mode:</span>
                 <input type="radio" id="modePerimeter" name="drawingMode" value="perimeter" checked>
                 <label for="modePerimeter">Perimeter</label>
                 <input type="radio" id="modeInnerWall" name="drawingMode" value="innerWall">
                 <label for="modeInnerWall">Inner Wall</label>
             </div>
         </div>


        <div class="controls bg-white p-4 rounded-lg shadow-md mb-4 flex flex-wrap items-center justify-center gap-x-4 gap-y-2">
            <div class="flex items-center gap-2">
                <label for="scaleInput" class="text-sm font-medium text-gray-700 whitespace-nowrap">Scale:</label>
                <input type="number" id="scaleInput" value="10" min="0.01" step="0.1" class="w-20 border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                <span id="scaleUnitDisplay" class="text-sm text-gray-600">pixels/in</span>
            </div>

            <div class="flex items-center gap-2">
                <label for="unitSelect" class="text-sm font-medium text-gray-700">Display Unit:</label>
                <select id="unitSelect" class="border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                    <option value="inches">Inches (in)</option>
                    <option value="feet" selected>Feet (ft)</option> <option value="feet-inches">Feet & Inches (ft-in)</option>
                    <option value="meters">Meters (m)</option>
                    <option value="cm">Centimeters (cm)</option>
                </select>
            </div>

             <div class="flex items-center gap-2">
                 <span class="text-sm font-medium text-gray-700">Floor Area:</span>
                 <span id="areaOutput" class="text-sm font-semibold text-indigo-600">0.00</span>
                 <span id="areaUnit" class="text-sm text-gray-600">sq ft</span> </div>

            <div class="flex items-center gap-2">
                <label for="imageUpload" class="custom-file-upload">
                    Upload BG
                </label>
                <input type="file" id="imageUpload" accept="image/*">
                 <button id="removeBgButton" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-3 rounded-md shadow text-xs" title="Remove Background Image">X</button>
            </div>
             <span class="text-xs text-gray-500 italic ml-2">(Or paste/drag)</span>

             <button id="undoActionButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md shadow">
                Undo Action
            </button>
             <button id="clearLayerButton" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-md shadow">
                Clear Layer
            </button>
             <button id="resetAllButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md shadow">
                Reset All
            </button>
        </div>

         <div id="scaleDefinition" class="hidden bg-yellow-50 p-3 rounded-md border border-yellow-300 shadow-sm mb-4 flex flex-col sm:flex-row items-center justify-center gap-2">
             <label for="distanceInput" class="text-sm font-medium text-gray-700 whitespace-nowrap">Distance of first segment:</label>
             <input type="number" id="distanceInput" min="0.01" step="0.01" class="w-24 border-gray-300 rounded-md shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
             <span id="distanceInputUnit" class="text-sm text-gray-600">in</span>
             <button id="setScaleButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-md shadow text-sm">Set Scale</button>
        </div>

        <div id="canvasContainer" class="canvas-container">
            <canvas id="drawingCanvas"></canvas>
             <div id="tempLinePreview" style="position: absolute; border-top: 1px dashed #555; pointer-events: none; display: none; z-index: 5;"></div>
        </div>

        <h2 class="text-xl font-semibold text-gray-700 mb-2 text-center">Area Summary</h2>
        <div class="overflow-x-auto">
             <table id="summaryTable" class="summary-table min-w-full">
                 <thead>
                     <tr>
                         <th>Layer Name</th>
                         <th class="area-col">Floor Area (sq ft)</th>
                         <th class="area-col">Wall Surface (sq ft)</th>
                     </tr>
                 </thead>
                 <tbody id="summaryTableBody">
                     </tbody>
                 <tfoot>
                     <tr>
                         <td><strong>Totals</strong></td>
                         <td class="area-col"><strong id="totalFloorAreaOutput">0.00 sq ft</strong></td>
                         <td class="area-col"><strong id="totalWallAreaOutput">0.00 sq ft</strong></td>
                     </tr>
                 </tfoot>
             </table>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const scaleInput = document.getElementById('scaleInput');
        const scaleUnitDisplay = document.getElementById('scaleUnitDisplay');
        const unitSelect = document.getElementById('unitSelect');
        const areaOutput = document.getElementById('areaOutput'); // Now Floor Area
        const areaUnit = document.getElementById('areaUnit');
        const undoActionButton = document.getElementById('undoActionButton'); // Renamed
        const clearLayerButton = document.getElementById('clearLayerButton');
        const resetAllButton = document.getElementById('resetAllButton');
        const canvasContainer = document.getElementById('canvasContainer');
        const imageUpload = document.getElementById('imageUpload');
        const removeBgButton = document.getElementById('removeBgButton');
        const messageBox = document.getElementById('messageBox');
        const instructionText = document.getElementById('instructionText');
        const scaleDefinitionDiv = document.getElementById('scaleDefinition');
        const distanceInput = document.getElementById('distanceInput');
        const distanceInputUnit = document.getElementById('distanceInputUnit');
        const setScaleButton = document.getElementById('setScaleButton');
        const layerTabsContainer = document.getElementById('layerTabsContainer');
        const addLayerButton = document.getElementById('addLayerButton');
        const summaryTableBody = document.getElementById('summaryTableBody');
        const totalFloorAreaOutput = document.getElementById('totalFloorAreaOutput'); // Updated ID
        const totalWallAreaOutput = document.getElementById('totalWallAreaOutput'); // New ID
        const ceilingHeightInput = document.getElementById('ceilingHeightInput');
        const ceilingHeightUnit = document.getElementById('ceilingHeightUnit');
        const drawingModeRadios = document.querySelectorAll('input[name="drawingMode"]');
        const tempLinePreview = document.getElementById('tempLinePreview');


        // --- State Variables ---
        let layers = [];
        let activeLayerId = null;
        let nextLayerId = 1;
        let selectedPointIndex = null; // Index of the perimeter point being dragged
        let isDragging = false;        // Flag if a perimeter point is currently being dragged
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let currentDrawingMode = 'perimeter'; // 'perimeter' or 'innerWall'
        let innerWallStartPoint = null; // Temporarily store start point when drawing inner wall
        let lastAction = null; // Track last action for undo ('addPerimeter', 'addWall')
        let interactionEndedOffCanvas = false; // Flag to track if interaction ended outside

        // --- Constants ---
        const INCHES_PER_FOOT = 12;
        const INCHES_PER_METER = 39.3701;
        const INCHES_PER_CM = 0.393701;
        const FEET_PER_METER = 1 / 0.3048; // More precise
        const CM_PER_INCH = 2.54;
        const POINT_RADIUS = 6;
        const HIT_RADIUS = 12;

        // --- Utility Functions ---
        function showMessage(message, duration = 3000) { /* ... no changes ... */ messageBox.textContent = message; messageBox.style.display = 'block'; if (messageBox.timeoutId) clearTimeout(messageBox.timeoutId); messageBox.timeoutId = setTimeout(() => { messageBox.style.display = 'none'; messageBox.timeoutId = null; }, duration); }
        function generateLayerId() { /* ... no changes ... */ return `layer_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`; }
        function getActiveLayer() { /* ... no changes ... */ if (!activeLayerId) return null; return layers.find(layer => layer.id === activeLayerId); }

        // --- Layer Management ---
        function createNewLayer(name = `Layer ${nextLayerId++}`) { /* ... no changes ... */ const newLayer = { id: generateLayerId(), name: name, perimeterPoints: [], innerWalls: [], backgroundImageUrl: null, scalePixelsPerInch: null, isScaleDefinedByUser: false, pixelDistanceFirstSegment: 0, ceilingHeightInches: 8 * INCHES_PER_FOOT, floorAreaSqPixels: 0, wallLengthPixels: 0, distanceLabels: [] }; return newLayer; }
        function addLayer(switchToNew = true) { /* ... no changes ... */ const newLayer = createNewLayer(); layers.push(newLayer); renderLayerTabs(); if (switchToNew) { switchLayer(newLayer.id); } updateSummaryTable(); if(layers.length === 1 && switchToNew) { updateInstructionText(); } }
        function switchLayer(layerId) { /* ... no changes ... */ if (activeLayerId === layerId) return; isDragging = false; selectedPointIndex = null; innerWallStartPoint = null; activeLayerId = layerId; const layer = getActiveLayer(); if (!layer) { console.error("Attempted to switch to non-existent layer:", layerId); activeLayerId = null; if (layers.length > 0) { switchLayer(layers[0].id); } else { clearCanvasAndUI(); updateInstructionText(); } return; } scaleInput.value = layer.scalePixelsPerInch !== null ? layer.scalePixelsPerInch.toFixed(4) : '10'; scaleInput.readOnly = layer.isScaleDefinedByUser; scaleInput.classList.toggle('cursor-not-allowed', layer.isScaleDefinedByUser); scaleInput.classList.toggle('bg-gray-200', layer.isScaleDefinedByUser); scaleUnitDisplay.textContent = 'pixels/in'; scaleDefinitionDiv.classList.toggle('hidden', !(layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser)); if (layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser) { distanceInputUnit.textContent = getUnitAbbreviation(unitSelect.value); distanceInput.focus(); } updateCeilingHeightInput(); document.getElementById('modePerimeter').checked = true; currentDrawingMode = 'perimeter'; setBackgroundImage(layer.backgroundImageUrl, false); updateActiveLayerAreaDisplay(); renderLayerTabs(); updateInstructionText(); requestAnimationFrame(draw); }
        function deleteLayer(layerIdToDelete) { // FIX: Correctly switch layer after deletion
             if (layers.length <= 1) { showMessage("Cannot delete the last layer.", 3000); return; }
             const layerIndexToDelete = layers.findIndex(l => l.id === layerIdToDelete); if (layerIndexToDelete === -1) return;

             const deletedLayerWasActive = activeLayerId === layerIdToDelete;

             // Remove layer data
             layers.splice(layerIndexToDelete, 1);

             // If the deleted layer was active, switch to the new first layer
             if (deletedLayerWasActive) {
                 activeLayerId = null; // Force switch
                 if (layers.length > 0) {
                     switchLayer(layers[0].id); // Switch to the new first layer
                 } else {
                     // This case should technically not be reachable due to the initial check,
                     // but handle it defensively.
                     clearCanvasAndUI();
                     renderLayerTabs(); // Show only add button
                     updateSummaryTable();
                     updateInstructionText();
                 }
             } else {
                 // If a different layer was deleted, just re-render tabs and table
                 renderLayerTabs();
                 updateSummaryTable();
             }
             showMessage("Layer deleted.", 2000);
        }
        function renameLayer(layerId, newName) { /* ... no changes ... */ const layer = layers.find(l => l.id === layerId); if (layer && newName.trim()) { layer.name = newName.trim(); renderLayerTabs(); updateSummaryTable(); } }
        function renderLayerTabs() { /* ... no changes ... */ layerTabsContainer.innerHTML = ''; layerTabsContainer.appendChild(addLayerButton); layers.forEach(layer => { const tab = document.createElement('div'); tab.className = 'layer-tab flex items-center'; tab.dataset.layerId = layer.id; tab.classList.toggle('active', layer.id === activeLayerId); const nameSpan = document.createElement('span'); nameSpan.textContent = layer.name; nameSpan.style.cursor = 'pointer'; nameSpan.addEventListener('click', (e) => { if (!e.target.classList.contains('rename-input')) { switchLayer(layer.id); } }); nameSpan.addEventListener('dblclick', () => { nameSpan.style.display = 'none'; input.style.display = 'inline-block'; input.value = layer.name; input.focus(); input.select(); }); const input = document.createElement('input'); input.type = 'text'; input.className = 'rename-input'; input.style.display = 'none'; input.addEventListener('blur', () => { renameLayer(layer.id, input.value); input.style.display = 'none'; nameSpan.style.display = 'inline-block'; }); input.addEventListener('keydown', (e) => { if (e.key === 'Enter') input.blur(); else if (e.key === 'Escape') { input.value = layer.name; input.blur(); } }); const closeBtn = document.createElement('button'); closeBtn.className = 'close-btn'; closeBtn.innerHTML = '&times;'; closeBtn.title = `Delete ${layer.name}`; closeBtn.addEventListener('click', (e) => { e.stopPropagation(); if (confirm(`Are you sure you want to delete layer "${layer.name}"? This cannot be undone.`)) { deleteLayer(layer.id); } }); tab.appendChild(nameSpan); tab.appendChild(input); if (layers.length > 1) { tab.appendChild(closeBtn); } layerTabsContainer.insertBefore(tab, addLayerButton); }); }
        function updateInstructionText() { /* ... no changes ... */ const layer = getActiveLayer(); if (!layer) { instructionText.textContent = "Add or select a layer to begin."; return; } let baseText = `Layer "${layer.name}": `; if (layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser) { baseText += `Enter distance below and click 'Set Scale'. (Cannot draw yet).`; } else if (currentDrawingMode === 'perimeter') { if (layer.perimeterPoints.length === 0) baseText += `PERIMETER MODE - Click empty space for first point.`; else if (layer.perimeterPoints.length === 1 && !layer.isScaleDefinedByUser) baseText += `PERIMETER MODE - Click empty space for second point to define scale.`; else baseText += `PERIMETER MODE - Click empty space to add points, or click & drag points to move.`; } else { if (innerWallStartPoint) baseText += `INNER WALL MODE - Click to set wall end point.`; else baseText += `INNER WALL MODE - Click to set wall start point.`; } if (!layer.backgroundImageUrl) { baseText += " (Optional: Upload/paste/drag BG image.)"; } instructionText.textContent = baseText; }

        // --- Canvas Resizing ---
        function resizeCanvas() { /* ... no changes ... */ const containerWidth = canvasContainer.clientWidth; const containerHeight = canvasContainer.clientHeight; const dpr = window.devicePixelRatio || 1; canvas.width = containerWidth * dpr; canvas.height = containerHeight * dpr; ctx.scale(dpr, dpr); canvas.style.width = `${containerWidth}px`; canvas.style.height = `${containerHeight}px`; requestAnimationFrame(draw); }
        window.addEventListener('resize', resizeCanvas);
        const resizeObserver = new ResizeObserver(resizeCanvas); resizeObserver.observe(document.querySelector('.controls'));

        // --- Unit and Scale Functions ---
        function getLayerScale(layer) { /* ... no changes ... */ return layer?.scalePixelsPerInch ?? 10.0; }
        function convertDisplayValueToInches(value, displayUnit) { /* ... no changes ... */ if (isNaN(value)) return 0; switch (displayUnit) { case 'feet': return value * INCHES_PER_FOOT; case 'meters': return value * INCHES_PER_METER; case 'cm': return value * INCHES_PER_CM; case 'feet-inches': showMessage("Using decimal feet for ft-in input.", 3000); return value * INCHES_PER_FOOT; case 'inches': default: return value; } }
        function convertInchesToDisplayValue(inches, displayUnit) { /* ... no changes ... */ if (isNaN(inches)) return 0; switch (displayUnit) { case 'feet': return inches / INCHES_PER_FOOT; case 'meters': return inches / INCHES_PER_METER; case 'cm': return inches / INCHES_PER_CM; case 'feet-inches': return inches / INCHES_PER_FOOT; case 'inches': default: return inches; } }
        function convertPixelsToUnit(pixels, displayUnit, layer) { /* ... no changes ... */ const scale = getLayerScale(layer); if (scale === 0) return 0; const inches = pixels / scale; return convertInchesToDisplayValue(inches, displayUnit); }
        function formatDistance(distanceValue, displayUnit) { /* ... no changes ... */ if (displayUnit === 'feet-inches') { if (typeof distanceValue === 'object' && distanceValue !== null && 'feet' in distanceValue && 'inches' in distanceValue) { const inchesStr = distanceValue.inches >= 0.05 || distanceValue.feet === 0 ? ` ${distanceValue.inches.toFixed(1)}in` : ''; return `${distanceValue.feet}ft${inchesStr}`; } else { return `${(distanceValue).toFixed(2)} ft`; } } else if (typeof distanceValue === 'number') { return `${distanceValue.toFixed(2)} ${getUnitAbbreviation(displayUnit)}`; } return 'N/A'; }
        function getUnitAbbreviation(displayUnit) { /* ... no changes ... */ switch (displayUnit) { case 'inches': return 'in'; case 'feet': return 'ft'; case 'feet-inches': return 'ft'; case 'meters': return 'm'; case 'cm': return 'cm'; default: return ''; } }
        function getAreaUnitAbbreviation(displayUnit) { /* ... no changes ... */ switch (displayUnit) { case 'inches': return 'sq in'; case 'feet': return 'sq ft'; case 'feet-inches': return 'sq ft'; case 'meters': return 'sq m'; case 'cm': return 'sq cm'; default: return ''; } }
        function convertAreaToUnit(pixelArea, displayUnit, layer) { /* ... no changes ... */ const scale = getLayerScale(layer); if (scale === 0) return 0; const squareInches = pixelArea / (scale * scale); const squareFeet = squareInches / (INCHES_PER_FOOT * INCHES_PER_FOOT); switch (displayUnit) { case 'feet': case 'feet-inches': return squareFeet; case 'meters': return squareFeet / (FEET_PER_METER * FEET_PER_METER); case 'cm': return squareInches * (CM_PER_INCH * CM_PER_INCH); case 'inches': default: return squareInches; } }
        function convertPixelAreaToSqFt(pixelArea, layer) { /* ... no changes ... */ const scale = getLayerScale(layer); if (scale === 0) return 0; const squareInches = pixelArea / (scale * scale); return squareInches / (INCHES_PER_FOOT * INCHES_PER_FOOT); }
        function convertPixelLengthToFt(pixelLength, layer) { /* ... no changes ... */ const scale = getLayerScale(layer); if (scale === 0) return 0; const inches = pixelLength / scale; return inches / INCHES_PER_FOOT; }

        // --- Drawing Functions ---
        function drawPoint(x, y, isSelected = false) { /* ... no changes ... */ if (isSelected) { ctx.fillStyle = 'rgba(59, 130, 246, 0.5)'; ctx.beginPath(); ctx.arc(x, y, POINT_RADIUS + 4, 0, Math.PI * 2); ctx.fill(); } ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(x, y, POINT_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 1; ctx.stroke(); }
        function drawLine(p1, p2, options = {}) { /* ... no changes ... */ const { color = '#ef4444', width = 2.5, dashed = false, dashPattern = [5, 5], shadow = true } = options; ctx.lineWidth = width; ctx.setLineDash(dashed ? dashPattern : []); ctx.strokeStyle = color; if (shadow) { ctx.shadowColor = 'rgba(255, 255, 255, 0.7)'; ctx.shadowBlur = 3; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0; } else { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; } ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); ctx.setLineDash([]); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }
        function drawTempLinePreview(start, end) { /* ... no changes ... */ const dx = end.x - start.x; const dy = end.y - start.y; const angle = Math.atan2(dy, dx); const length = Math.sqrt(dx * dx + dy * dy); tempLinePreview.style.left = `${start.x}px`; tempLinePreview.style.top = `${start.y}px`; tempLinePreview.style.width = `${length}px`; tempLinePreview.style.transformOrigin = '0 0'; tempLinePreview.style.transform = `rotate(${angle}rad)`; tempLinePreview.style.display = 'block'; }
        function hideTempLinePreview() { /* ... no changes ... */ tempLinePreview.style.display = 'none'; }

        // --- Calculation Functions ---
        function calculateDistance(p1, p2) { /* ... no changes ... */ const dx = p2.x - p1.x; const dy = p2.y - p1.y; return Math.sqrt(dx * dx + dy * dy); }
        function calculatePolygonArea(pts) { /* ... no changes ... */ let area = 0; const n = pts.length; if (n < 3) return 0; for (let i = 0; i < n; i++) { const p1 = pts[i]; const p2 = pts[(i + 1) % n]; area += (p1.x * p2.y - p2.x * p1.y); } return Math.abs(area) / 2; }
        function calculateTotalWallLengthPixels(layer) { /* ... no changes ... */ let totalLength = 0; if (layer.perimeterPoints.length >= 2) { for (let i = 0; i < layer.perimeterPoints.length; i++) { const p1 = layer.perimeterPoints[i]; const p2 = layer.perimeterPoints[(i + 1) % layer.perimeterPoints.length]; totalLength += calculateDistance(p1, p2); } } layer.innerWalls.forEach(wall => { totalLength += calculateDistance(wall.start, wall.end); }); return totalLength; }

        // --- Background Image Handling ---
        function setBackgroundImage(imageUrl, showMsg = true) { /* ... no changes ... */ const layer = getActiveLayer(); if (!layer) return; layer.backgroundImageUrl = imageUrl; canvasContainer.style.backgroundImage = imageUrl ? `url(${imageUrl})` : 'none'; canvasContainer.style.backgroundColor = imageUrl ? '#cccccc' : '#f0f9ff'; if (showMsg && imageUrl) showMessage('Background image set for current layer.', 2000); if (showMsg && !imageUrl) showMessage('Background image removed for current layer.', 2000); updateInstructionText(); }
        function removeBackgroundImage() { /* ... no changes ... */ setBackgroundImage(null); imageUpload.value = null; }
        function handleImageFile(file) { /* ... no changes ... */ if (file && file.type.startsWith('image/')) { const reader = new FileReader(); reader.onload = (e) => setBackgroundImage(e.target.result); reader.onerror = () => showMessage('Error reading image file.', 3000); reader.readAsDataURL(file); } else { showMessage('Please select/drop a valid image file.', 3000); } }

        // --- Main Drawing Loop (Draws Active Layer) ---
        function draw() { /* ... no changes ... */ ctx.clearRect(0, 0, canvas.width, canvas.height); const layer = getActiveLayer(); document.querySelectorAll('.distance-label').forEach(label => label.remove()); if (layer) { layer.distanceLabels = []; } else { updateActiveLayerAreaDisplay(); return; } if (layer.perimeterPoints.length === 0 && layer.innerWalls.length === 0) { updateActiveLayerAreaDisplay(); return; } const selectedDisplayUnit = unitSelect.value; const isScalePending = (layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser); layer.innerWalls.forEach(wall => { drawLine(wall.start, wall.end, { color: '#6b7280', width: 1.5, dashed: true, dashPattern: [4, 4], shadow: false }); if (layer.isScaleDefinedByUser) { const pixelDist = calculateDistance(wall.start, wall.end); const unitDist = convertPixelsToUnit(pixelDist, selectedDisplayUnit, layer); const formattedDist = formatDistance(unitDist, selectedDisplayUnit); const midX = (wall.start.x + wall.end.x) / 2; const midY = (wall.start.y + wall.end.y) / 2; const angle = Math.atan2(wall.end.y - wall.start.y, wall.end.x - wall.start.x); const offsetX = Math.sin(angle) * 8; const offsetY = -Math.cos(angle) * 8; const label = document.createElement('div'); label.className = 'distance-label'; label.textContent = formattedDist; label.style.left = `${midX + offsetX}px`; label.style.top = `${midY + offsetY}px`; label.style.fontSize = '0.7rem'; label.style.padding = '1px 3px'; canvasContainer.appendChild(label); layer.distanceLabels.push(label); } }); if (layer.perimeterPoints.length >= 2) { for (let i = 0; i < layer.perimeterPoints.length - 1; i++) { const p1 = layer.perimeterPoints[i]; const p2 = layer.perimeterPoints[i + 1]; const isCurrentSegmentFirst = (i === 0); drawLine(p1, p2, { dashed: isCurrentSegmentFirst && isScalePending }); if (layer.isScaleDefinedByUser || !isCurrentSegmentFirst) { const pixelDist = calculateDistance(p1, p2); const unitDist = convertPixelsToUnit(pixelDist, selectedDisplayUnit, layer); const formattedDist = formatDistance(unitDist, selectedDisplayUnit); const midX = (p1.x + p2.x) / 2; const midY = (p1.y + p2.y) / 2; const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x); const offsetX = Math.sin(angle) * 10; const offsetY = -Math.cos(angle) * 10; const label = document.createElement('div'); label.className = 'distance-label'; label.textContent = formattedDist; label.style.left = `${midX + offsetX}px`; label.style.top = `${midY + offsetY}px`; canvasContainer.appendChild(label); layer.distanceLabels.push(label); } } if (layer.perimeterPoints.length >= 3 && layer.isScaleDefinedByUser) { const pLast = layer.perimeterPoints[layer.perimeterPoints.length - 1]; const pFirst = layer.perimeterPoints[0]; drawLine(pLast, pFirst); const pixelDist = calculateDistance(pLast, pFirst); const unitDist = convertPixelsToUnit(pixelDist, selectedDisplayUnit, layer); const formattedDist = formatDistance(unitDist, selectedDisplayUnit); const midX = (pLast.x + pFirst.x) / 2; const midY = (pLast.y + pFirst.y) / 2; const angle = Math.atan2(pFirst.y - pLast.y, pFirst.x - pLast.x); const offsetX = Math.sin(angle) * 10; const offsetY = -Math.cos(angle) * 10; const label = document.createElement('div'); label.className = 'distance-label'; label.textContent = formattedDist; label.style.left = `${midX + offsetX}px`; label.style.top = `${midY + offsetY}px`; canvasContainer.appendChild(label); layer.distanceLabels.push(label); } } if (layer.isScaleDefinedByUser) { layer.floorAreaSqPixels = calculatePolygonArea(layer.perimeterPoints); layer.wallLengthPixels = calculateTotalWallLengthPixels(layer); } else { layer.floorAreaSqPixels = 0; layer.wallLengthPixels = 0; } layer.perimeterPoints.forEach((p, index) => drawPoint(p.x, p.y, index === selectedPointIndex)); updateActiveLayerAreaDisplay(); updateSummaryTable(); }
        function updateActiveLayerAreaDisplay() { /* ... no changes ... */ const layer = getActiveLayer(); const displayUnit = unitSelect.value; if (layer && layer.isScaleDefinedByUser) { const unitArea = convertAreaToUnit(layer.floorAreaSqPixels, displayUnit, layer); areaOutput.textContent = unitArea.toFixed(2); areaUnit.textContent = getAreaUnitAbbreviation(displayUnit); } else { areaOutput.textContent = '0.00'; areaUnit.textContent = getAreaUnitAbbreviation(displayUnit); } }

        // --- Interaction Event Handlers ---
        function getEventCoords(event) { /* ... no changes ... */ const rect = canvas.getBoundingClientRect(); let clientX, clientY; if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else if (event.clientX !== undefined) { clientX = event.clientX; clientY = event.clientY; } else { return null; } return { x: clientX - rect.left, y: clientY - rect.top }; }
        function findHitPoint(coords, layer) { /* ... no changes ... */ if (!coords || !layer) return -1; for (let i = layer.perimeterPoints.length - 1; i >= 0; i--) { const point = layer.perimeterPoints[i]; const dist = calculateDistance(coords, point); if (dist <= HIT_RADIUS) { return i; } } return -1; }

        function handleInteractionStart(event) {
            const layer = getActiveLayer(); if (!layer) return;
            if (event.type === 'touchstart') { event.preventDefault(); }
            const coords = getEventCoords(event); if (!coords) return;

            interactionEndedOffCanvas = false; // Reset flag on new interaction start

            // Block if scale definition pending
            if (layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser) { showMessage(`Please define the scale for layer "${layer.name}" first.`, 3500); scaleDefinitionDiv.classList.add('ring-2', 'ring-red-500'); setTimeout(() => scaleDefinitionDiv.classList.remove('ring-2', 'ring-red-500'), 1000); return; }

            if (currentDrawingMode === 'perimeter') {
                selectedPointIndex = findHitPoint(coords, layer);
                if (selectedPointIndex !== -1) { // Start dragging perimeter point
                    isDragging = true; const point = layer.perimeterPoints[selectedPointIndex];
                    dragOffsetX = coords.x - point.x; dragOffsetY = coords.y - point.y;
                    canvas.style.cursor = 'grabbing'; requestAnimationFrame(draw);
                } else { // Not dragging, potential perimeter point add on end
                    isDragging = false; selectedPointIndex = null; canvas.style.cursor = 'crosshair';
                }
            } else { // Inner Wall Mode
                isDragging = false; selectedPointIndex = null;
                if (!innerWallStartPoint) { // Start drawing an inner wall
                    innerWallStartPoint = { x: coords.x, y: coords.y };
                    hideTempLinePreview(); canvas.style.cursor = 'copy'; updateInstructionText();
                } else { // Ready to finish drawing inner wall (on end event)
                     canvas.style.cursor = 'crosshair';
                }
            }
        }

        function handleInteractionMove(event) {
            const layer = getActiveLayer(); if (!layer) return;
            if (event.type === 'touchmove') { event.preventDefault(); }
            const coords = getEventCoords(event); if (!coords) return;

            if (isDragging && currentDrawingMode === 'perimeter' && selectedPointIndex !== null) { // Dragging perimeter point
                layer.perimeterPoints[selectedPointIndex].x = coords.x - dragOffsetX;
                layer.perimeterPoints[selectedPointIndex].y = coords.y - dragOffsetY;
                requestAnimationFrame(draw);
            } else if (currentDrawingMode === 'innerWall' && innerWallStartPoint) { // Previewing inner wall
                 drawTempLinePreview(innerWallStartPoint, coords);
            }
        }

        function handleInteractionEnd(event) {
             // Check if the interaction actually ended off-canvas
             if (interactionEndedOffCanvas) {
                 interactionEndedOffCanvas = false; // Reset flag
                 // If dragging, finalize the drag based on the last known position before leaving
                 if (isDragging && currentDrawingMode === 'perimeter') {
                     isDragging = false;
                     canvas.style.cursor = 'crosshair';
                     requestAnimationFrame(draw); // Redraw with final position
                 }
                 // If drawing an inner wall, cancel it
                 else if (currentDrawingMode === 'innerWall' && innerWallStartPoint) {
                     innerWallStartPoint = null;
                     hideTempLinePreview();
                     canvas.style.cursor = 'crosshair';
                     updateInstructionText();
                     showMessage("Wall drawing cancelled (mouse left canvas).", 2000);
                 }
                 return; // Do not add points if interaction ended off-canvas
             }


            const layer = getActiveLayer(); if (!layer) return;
            const coords = getEventCoords(event); // Get coords for potential point add

            canvas.style.cursor = 'crosshair'; // Reset cursor
            hideTempLinePreview(); // Hide preview line

            if (isDragging && currentDrawingMode === 'perimeter') { // Finished dragging perimeter point
                isDragging = false; requestAnimationFrame(draw);
            } else if (currentDrawingMode === 'perimeter' && !isDragging) { // Add perimeter point
                 if (!(layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser)) {
                     if (coords) { // Ensure coords are valid (click happened on canvas)
                        layer.perimeterPoints.push({ x: coords.x, y: coords.y });
                        lastAction = 'addPerimeter'; // Track action
                        // Handle scale definition trigger
                        if (layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser) {
                            layer.pixelDistanceFirstSegment = calculateDistance(layer.perimeterPoints[0], layer.perimeterPoints[1]);
                            scaleDefinitionDiv.classList.remove('hidden'); distanceInputUnit.textContent = getUnitAbbreviation(unitSelect.value);
                            distanceInput.value = ''; distanceInput.focus(); scaleInput.readOnly = true;
                            scaleInput.classList.add('cursor-not-allowed', 'bg-gray-200');
                            showMessage(`Define the length of the yellow dashed line for layer "${layer.name}".`, 4000);
                        }
                        updateInstructionText(); requestAnimationFrame(draw);
                    }
                 }
            } else if (currentDrawingMode === 'innerWall') { // Finish drawing inner wall
                 if (innerWallStartPoint && coords) { // Ensure coords are valid
                     // Avoid adding zero-length walls
                     if (calculateDistance(innerWallStartPoint, coords) > 1) {
                         layer.innerWalls.push({ start: innerWallStartPoint, end: { x: coords.x, y: coords.y } });
                         lastAction = 'addWall'; // Track action
                         requestAnimationFrame(draw);
                     }
                 }
                 innerWallStartPoint = null; // Reset for next wall
                 updateInstructionText();
            }
        }

         // Specific handler for mouse leaving the canvas
         function handleMouseLeave(event) {
             if (isDragging || innerWallStartPoint) {
                 interactionEndedOffCanvas = true; // Set flag
                 handleInteractionEnd(event); // Call the end handler to clean up state
             }
         }


        function handleUndoAction() { /* ... no changes ... */ const layer = getActiveLayer(); if (!layer) { showMessage("No active layer to undo actions on.", 2000); return; } if (lastAction === 'addPerimeter' && layer.perimeterPoints.length > 0) { const wasScalePendingOrDefined = layer.isScaleDefinedByUser || (layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser); const removingSecondPoint = layer.perimeterPoints.length === 2; layer.perimeterPoints.pop(); if (removingSecondPoint && wasScalePendingOrDefined) { layer.isScaleDefinedByUser = false; layer.scalePixelsPerInch = null; layer.pixelDistanceFirstSegment = 0; scaleDefinitionDiv.classList.add('hidden'); scaleInput.readOnly = false; scaleInput.classList.remove('cursor-not-allowed', 'bg-gray-200'); scaleInput.value = '10'; showMessage("Scale definition reset as second point was removed.", 3000); } if (selectedPointIndex !== null && selectedPointIndex >= layer.perimeterPoints.length) { selectedPointIndex = null; } showMessage("Last perimeter point removed.", 1500); lastAction = null; updateInstructionText(); requestAnimationFrame(draw); } else if (lastAction === 'addWall' && layer.innerWalls.length > 0) { layer.innerWalls.pop(); showMessage("Last inner wall removed.", 1500); lastAction = null; updateInstructionText(); requestAnimationFrame(draw); } else { showMessage("Nothing to undo.", 1500); } }
        function handleSetScale() { /* ... no changes ... */ const layer = getActiveLayer(); if (!layer || layer.perimeterPoints.length < 2) return; const realDistance = parseFloat(distanceInput.value); const scaleDefinitionUnit = unitSelect.value; if (!realDistance || realDistance <= 0) { showMessage("Please enter a valid positive distance.", 3000); return; } if (layer.pixelDistanceFirstSegment <= 0) { showMessage("Cannot set scale. Invalid first segment drawn.", 3000); return; } const realDistanceInInches = convertDisplayValueToInches(realDistance, scaleDefinitionUnit); if (realDistanceInInches <= 0) { showMessage("Cannot calculate scale with the entered value or unit.", 3000); return; } layer.scalePixelsPerInch = layer.pixelDistanceFirstSegment / realDistanceInInches; layer.isScaleDefinedByUser = true; scaleInput.value = layer.scalePixelsPerInch.toFixed(4); scaleInput.readOnly = true; scaleInput.classList.add('cursor-not-allowed', 'bg-gray-200'); scaleDefinitionDiv.classList.add('hidden'); showMessage(`Scale set for layer "${layer.name}". You can now add more points.`, 3500); updateInstructionText(); requestAnimationFrame(draw); }
        function clearActiveLayer() { /* ... no changes ... */ const layer = getActiveLayer(); if (!layer) { showMessage("No active layer to clear.", 2000); return; } if (!confirm(`Are you sure you want to clear all points, walls, scale, and background for layer "${layer.name}"?`)) { return; } layer.distanceLabels.forEach(label => label.remove()); layer.perimeterPoints = []; layer.innerWalls = []; layer.backgroundImageUrl = null; layer.scalePixelsPerInch = null; layer.isScaleDefinedByUser = false; layer.pixelDistanceFirstSegment = 0; layer.floorAreaSqPixels = 0; layer.wallLengthPixels = 0; layer.distanceLabels = []; layer.ceilingHeightInches = 8 * INCHES_PER_FOOT; isDragging = false; selectedPointIndex = null; innerWallStartPoint = null; lastAction = null; canvas.style.cursor = 'crosshair'; scaleInput.value = '10'; scaleInput.readOnly = false; scaleInput.classList.remove('cursor-not-allowed', 'bg-gray-200'); scaleDefinitionDiv.classList.add('hidden'); setBackgroundImage(null, false); imageUpload.value = null; updateCeilingHeightInput(); updateActiveLayerAreaDisplay(); updateSummaryTable(); updateInstructionText(); showMessage(`Layer "${layer.name}" cleared.`, 2000); requestAnimationFrame(draw); }
        function resetAll() { /* ... no changes ... */ if (!confirm("Are you sure you want to reset all layers, points, scales, and backgrounds? This cannot be undone.")) { return; } document.querySelectorAll('.distance-label').forEach(label => label.remove()); layers = []; activeLayerId = null; nextLayerId = 1; isDragging = false; selectedPointIndex = null; innerWallStartPoint = null; lastAction = null; canvas.style.cursor = 'crosshair'; clearCanvasAndUI(); renderLayerTabs(); updateSummaryTable(); addLayer(true); showMessage("All layers reset.", 2500); updateInstructionText(); requestAnimationFrame(draw); }
        function clearCanvasAndUI() { /* ... no changes ... */ ctx.clearRect(0, 0, canvas.width, canvas.height); setBackgroundImage(null, false); scaleInput.value = '10'; scaleInput.readOnly = false; scaleInput.classList.remove('cursor-not-allowed', 'bg-gray-200'); scaleDefinitionDiv.classList.add('hidden'); imageUpload.value = null; updateActiveLayerAreaDisplay(); updateCeilingHeightInput(); }

        // --- Ceiling Height Handling ---
        function updateCeilingHeightInput() { /* ... no changes ... */ const layer = getActiveLayer(); const displayUnit = unitSelect.value; if (layer) { const displayHeight = convertInchesToDisplayValue(layer.ceilingHeightInches, displayUnit); ceilingHeightInput.value = displayHeight.toFixed(1); } else { ceilingHeightInput.value = convertInchesToDisplayValue(8 * INCHES_PER_FOOT, displayUnit).toFixed(1); } ceilingHeightUnit.textContent = getUnitAbbreviation(displayUnit); }
        function handleCeilingHeightChange() { /* ... no changes ... */ const layer = getActiveLayer(); if (!layer) return; const displayUnit = unitSelect.value; const heightValue = parseFloat(ceilingHeightInput.value); if (!isNaN(heightValue) && heightValue >= 0) { layer.ceilingHeightInches = convertDisplayValueToInches(heightValue, displayUnit); updateSummaryTable(); } else { updateCeilingHeightInput(); showMessage("Invalid ceiling height entered.", 2000); } }

        // --- Paste Image Handler ---
        window.addEventListener('paste', (event) => { /* ... no changes ... */ const layer = getActiveLayer(); if (!layer) return; const items = event.clipboardData?.items; if (!items) return; for (let i = 0; i < items.length; i++) { if (items[i].type.indexOf('image') !== -1) { const blob = items[i].getAsFile(); if (blob) { handleImageFile(blob); event.preventDefault(); showMessage(`Image pasted to layer "${layer.name}".`, 2000); return; } } } });

        // --- Drag and Drop Image Handlers ---
        canvasContainer.addEventListener('dragover', (event) => { /* ... no changes ... */ event.preventDefault(); event.stopPropagation(); if (getActiveLayer()) { canvasContainer.classList.add('drag-over'); } });
        canvasContainer.addEventListener('dragleave', (event) => { /* ... no changes ... */ event.preventDefault(); event.stopPropagation(); canvasContainer.classList.remove('drag-over'); });
        canvasContainer.addEventListener('drop', (event) => { /* ... no changes ... */ event.preventDefault(); event.stopPropagation(); canvasContainer.classList.remove('drag-over'); const layer = getActiveLayer(); if (!layer) { showMessage("Please select a layer before dropping an image.", 3000); return; } const files = event.dataTransfer?.files; if (files && files.length > 0) { const file = files[0]; if (file.type.startsWith('image/')) { handleImageFile(file); showMessage(`Image dropped onto layer "${layer.name}".`, 2000); } else { showMessage("Dropped file is not a valid image.", 3000); } } });

        // --- Summary Table Update ---
        function updateSummaryTable() { /* ... no changes ... */ summaryTableBody.innerHTML = ''; let totalFloorSqFt = 0; let totalWallSqFt = 0; layers.forEach(layer => { const row = summaryTableBody.insertRow(); const nameCell = row.insertCell(); const floorAreaCell = row.insertCell(); const wallAreaCell = row.insertCell(); nameCell.textContent = layer.name; floorAreaCell.classList.add('area-col'); wallAreaCell.classList.add('area-col'); let floorSqFt = 0; let wallSqFt = 0; if (layer.isScaleDefinedByUser) { if (layer.floorAreaSqPixels > 0) { floorSqFt = convertPixelAreaToSqFt(layer.floorAreaSqPixels, layer); floorAreaCell.textContent = floorSqFt.toFixed(2); } else { floorAreaCell.textContent = '0.00'; } if (layer.wallLengthPixels > 0 && layer.ceilingHeightInches > 0) { const totalWallLengthFt = convertPixelLengthToFt(layer.wallLengthPixels, layer); const ceilingHeightFt = layer.ceilingHeightInches / INCHES_PER_FOOT; wallSqFt = totalWallLengthFt * ceilingHeightFt; wallAreaCell.textContent = wallSqFt.toFixed(2); } else { wallAreaCell.textContent = '0.00'; } } else { floorAreaCell.textContent = '0.00'; wallAreaCell.textContent = '0.00'; } totalFloorSqFt += floorSqFt; totalWallSqFt += wallSqFt; }); totalFloorAreaOutput.textContent = `${totalFloorSqFt.toFixed(2)} sq ft`; totalWallAreaOutput.textContent = `${totalWallSqFt.toFixed(2)} sq ft`; }

        // --- Event Listeners ---
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mousemove', handleInteractionMove);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        canvas.addEventListener('mouseleave', handleMouseLeave); // Use specific handler for mouseleave
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        canvas.addEventListener('touchcancel', handleInteractionEnd); // Treat cancel like end
        addLayerButton.addEventListener('click', () => addLayer(true));
        undoActionButton.addEventListener('click', handleUndoAction);
        clearLayerButton.addEventListener('click', clearActiveLayer);
        resetAllButton.addEventListener('click', resetAll);
        setScaleButton.addEventListener('click', handleSetScale);
        removeBgButton.addEventListener('click', removeBackgroundImage);
        unitSelect.addEventListener('change', () => { /* ... no changes ... */ const layer = getActiveLayer(); if (layer && layer.perimeterPoints.length === 2 && !layer.isScaleDefinedByUser) { distanceInputUnit.textContent = getUnitAbbreviation(unitSelect.value); } updateCeilingHeightInput(); updateActiveLayerAreaDisplay(); requestAnimationFrame(draw); });
        scaleInput.addEventListener('input', () => { /* ... no changes ... */ const layer = getActiveLayer(); if (layer && !layer.isScaleDefinedByUser) { const manualScale = parseFloat(scaleInput.value); if (!isNaN(manualScale) && manualScale > 0) { layer.scalePixelsPerInch = manualScale; if(layer.points.length > 0) { requestAnimationFrame(draw); } } } else if (layer && layer.isScaleDefinedByUser) { scaleInput.value = layer.scalePixelsPerInch.toFixed(4); showMessage("Scale was set using the first segment and cannot be changed manually for this layer. Clear layer to reset scale.", 4000); } });
        imageUpload.addEventListener('change', (event) => { /* ... no changes ... */ if (getActiveLayer()) { if (event.target.files && event.target.files[0]) { handleImageFile(event.target.files[0]); } } else { showMessage("Please select a layer before uploading an image.", 3000); imageUpload.value = null; } });
        ceilingHeightInput.addEventListener('change', handleCeilingHeightChange);
        drawingModeRadios.forEach(radio => { /* ... no changes ... */ radio.addEventListener('change', (event) => { currentDrawingMode = event.target.value; innerWallStartPoint = null; hideTempLinePreview(); canvas.style.cursor = 'crosshair'; updateInstructionText(); }); });

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => { /* ... no changes ... */ addLayer(true); setTimeout(resizeCanvas, 100); });

    </script>

</body>
</html>